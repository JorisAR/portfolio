<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Joris&#39; Portfolio on Portfolio</title>
    <link>http://localhost:1313/portfolio/</link>
    <description>Recent content in Joris&#39; Portfolio on Portfolio</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 14 Jun 2025 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/portfolio/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Ray-Marched Voxel Simulation</title>
      <link>http://localhost:1313/portfolio/posts/voxelplayground/</link>
      <pubDate>Sat, 14 Jun 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/portfolio/posts/voxelplayground/</guid>
      <description>I have created a new voxel engine that is designed to handle fully dynamic scenes. Inspired by classic falling sand games, my aim was to create a system that can handle many unique interactions between different materials. The world is rendered using direct voxel volume rendering, such that changes to the world are immediately reflected on screen. As we are updating upwards of hundreds of millions of voxels, many times per second, the entire simulation is run on the GPU using compute shaders.</description>
    </item>
    <item>
      <title>Ray Marching Fractals that move to Music</title>
      <link>http://localhost:1313/portfolio/posts/dancingfractals/</link>
      <pubDate>Mon, 19 May 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/portfolio/posts/dancingfractals/</guid>
      <description>I wanted to combine my love for computer graphics and music, by creating a music video generator. The idea is to design a dynamic renderer that enables me to quickly iterate on some neat looking visuals that move to music playing in the background. I realized that one of the best options for this is ray marching, as we can apply many fun tricks to quickly create some sophisticated looking scenes with a bit of mathematics.</description>
    </item>
    <item>
      <title>Destructible Large-Scale Voxel Planets using Surface Nets</title>
      <link>http://localhost:1313/portfolio/posts/voxelplanets/</link>
      <pubDate>Sun, 13 Apr 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/portfolio/posts/voxelplanets/</guid>
      <description>A while back, I showed my first implementation of a Smooth Voxel Terrain. While I was reasonably satisfied, it left a lot to be desired. The terrain suffered from some artifacts and performance issues, and because it was programmed in C# it could not be easily integrated into other projects. For these reasons, I decided to start working on a new implementation from scratch in C++, addressing many of these problems.</description>
    </item>
    <item>
      <title>Path Tracing</title>
      <link>http://localhost:1313/portfolio/posts/pathtracing/</link>
      <pubDate>Sun, 16 Mar 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/portfolio/posts/pathtracing/</guid>
      <description>Update: Iâ€™m thrilled to share that this project has been featured in the community section of the April 2025 edition of the official Godot newsletter!&#xA;Ray and path tracing is becoming more and more popular in real-time graphics. Many modern games release with ray traced reflections, and some games even attempt to have full path traced global illumination, essentially modelling light like in real-life. However, Godot lacks a good path tracing solution.</description>
    </item>
    <item>
      <title>Training Evolutionary Agents</title>
      <link>http://localhost:1313/portfolio/posts/evolutionaryagents/</link>
      <pubDate>Wed, 22 Jan 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/portfolio/posts/evolutionaryagents/</guid>
      <description>Last time, I showcased some basics of Evolutionary Algorithms, which can elegantly solve black box problems. Today I extend it to train agents using reinforcement learning and neural networks. If you want to check it out for yourself, feel free to look at the source code.&#xA;Reinforcement learning is a branch of machine learning where agents aim to learn some behavior that maximizes the reward obtained in some environment by taking the right actions given a particular state.</description>
    </item>
    <item>
      <title>Simulating Digital Evolution</title>
      <link>http://localhost:1313/portfolio/posts/evolutionaryalgorithms/</link>
      <pubDate>Sun, 29 Dec 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/portfolio/posts/evolutionaryalgorithms/</guid>
      <description>Many problems are difficult to solve using classic algorithms. This is where state of the art artificial intelligence techniques come into play. While everyone talks about large language models and diffusers nowadays, I think a different branch called evolutionary algorithms is much more interesting. Originally inspired by biological evolution, this branch of artificial intelligence aims to solve problems using elegant concepts.&#xA;While many types of evolutionary algorithms exist, they almost all share the notion of using a population to converge to an optimal solution.</description>
    </item>
    <item>
      <title>Simulating Forest Fires</title>
      <link>http://localhost:1313/portfolio/posts/forestfires/</link>
      <pubDate>Sun, 24 Nov 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/portfolio/posts/forestfires/</guid>
      <description>Inspired by the Scintilla paper, I wanted to create interesting forest fire simulations on my procedurally generated Smooth Voxel Terrain.&#xA;To achieve it, I came up with the following requirements:&#xA;We need to come up with a system to modify the grass on the terrain. It needs to be able to visually indicate that it has been burnt, and in that case, it shouldn&amp;rsquo;t be able to be burnt again.</description>
    </item>
    <item>
      <title>Population of a Large-Scale Terrain</title>
      <link>http://localhost:1313/portfolio/posts/population/</link>
      <pubDate>Tue, 24 Sep 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/portfolio/posts/population/</guid>
      <description>Previously I introduced a Large-Scale Smooth Voxel Terrain While impressive in scale, it lacked visual variety and complexity. One way to mitigate this is by introducing natural objects such as grass and trees.&#xA;Many voxel engines and games such as minecraft tackle this by incorporating these features into voxels too, but this can both make asset creation more difficult, and increase the demands put on our voxel octree. Instead, I chose to implement more traditional methods of distributing objects on the terrain surface, often seen in games in combination with heightmap terrains.</description>
    </item>
    <item>
      <title>Real-Time Zelda inspired Isoline Map</title>
      <link>http://localhost:1313/portfolio/posts/isocontourmap/</link>
      <pubDate>Sun, 01 Sep 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/portfolio/posts/isocontourmap/</guid>
      <description>In 3D virtual environments, one can benefit greatly from having a map to lead them the way. Oftentimes maps are created by talented artists. However, when procedurally generating a terrain we have to create a map programmatically.&#xA;In our case, the goal is to generated a map for our procedurally generated Smooth Voxel Terrain. I planned out two possible solutions:&#xA;Generate a heightmap texture based on the octree. This would involve raymarching through the SDF for every pixel in the texture.</description>
    </item>
    <item>
      <title>Large-Scale Smooth Voxel Terrain</title>
      <link>http://localhost:1313/portfolio/posts/smoothvoxelterrain/</link>
      <pubDate>Fri, 30 Aug 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/portfolio/posts/smoothvoxelterrain/</guid>
      <description>Update: I rewrote this project from the ground up in C++, and I made some algorithmic improvements. Please refer to the new version.&#xA;Rendering large terrains is no easy task. In real-time computer graphics, terrains are often large subdivided planes with vertices translated vertically based on a heightmap, but this means that overhangs or caves are impossible without extra work or additional meshes. Instead, we can use a three dimensional volume to represent the terrain.</description>
    </item>
    <item>
      <title>University Projects</title>
      <link>http://localhost:1313/portfolio/posts/universityprojects/</link>
      <pubDate>Thu, 01 Aug 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/portfolio/posts/universityprojects/</guid>
      <description>I started studying at TU Delft in september 2020, and I have worked on many projects for courses since then. This is a collection of my proudest work related to computer graphics from my time at university. All other projects listed on my portfolio were made on my own, in my free time.&#xA;Pizzicato A serious game developed in 10 weeks with 4 other peers in collaboration with Psychology researchers, during which I was Game Designer and Programmer.</description>
    </item>
  </channel>
</rss>
